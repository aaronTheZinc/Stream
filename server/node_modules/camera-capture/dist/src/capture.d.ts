/// <reference types="node" />
import { CaptureBase } from './captureBase';
import { CaptureOptions, ImageData, Listener, SupportedFormats } from './types';
export declare class VideoCapture extends CaptureBase {
    protected o: CaptureOptions;
    protected capturing: boolean;
    protected initialized: boolean;
    protected lastFrame?: ImageData;
    protected listeners: Listener[];
    /** counts [shots] */
    protected counter: number;
    protected recording: boolean;
    constructor(o?: CaptureOptions);
    /**
     * Will be notified on managed frame shoot started by [start] method. Notice that this is optional and frames can be arbitrarily read using [readFrame]
     */
    addFrameListener(listener: Listener): void;
    /**
     * Turns off the camera. frame read loop triggered by [start] won't be cleared but listeners won't be called while camera is off.
     *
     * The camera can be turned on again by calling [startCamera]
     */
    stopCamera(): Promise<void>;
    /**
     * turns off everything, first recording , turns of camera, frame listeners and at last the server and browser. Everything can be restarted using [initialize] or alternatively [start] to restart frame listener notifications too
      */
    stop(): Promise<void>;
    /**
     * Won't turn off the camera but frame listeners won't be notified which will result on low cpu usage. Use it to switch between managed and manual frame read with [readFrame]. You can unpause calling [resume].
     */
    pause(): Promise<void>;
    isPaused(): boolean;
    isStopped(): boolean;
    isRecording(): boolean;
    /**
     * Resumes frame listener notification. See [pause].
     */
    resume(): Promise<void>;
    /**
     * Starts capturing camera video. If not calling yet it will call [initialize] and after camera is turned on it will start the capture loop, this is frame listeners notification. The loop, by default will be as fast as possible consequently with high cpu overhead. Use [pause] and[resume] to control it. Alternatively, if you just want to read frames arbitrarily y your self, just call [initialize] instead this method and use [readFrame].
     */
    start(): Promise<void>;
    /**
     * starts servers, browser, install scripts and global functions used , and start up the video and canvas elements.
     * ,media streams / canvas / video in the DOM.
     *
     * After it resolves the camera should be turned on , and methods like  [readFrame] and [startRecording] will be ready to be called..
     */
    initialize(): Promise<void>;
    /**
     * Just turn on the camera using given constrains and merging them with defaults and the ones given in constructor.
     *
     * After it resolves the camera should be turned on and methods like [readFrame] and [startRecording] will be ready to be called..
     */
    startCamera(o?: MediaStreamConstraints): Promise<void>;
    /**
     *  Uses [MediaRecorder] to start recording current captured video. Notice that this happens 100% on memory so take a look at RAM and the time it takes [stopRecording] to encode the video file.
     */
    startRecording(recordOptions?: {
        mimeType: string;
        width: number;
        height: number;
    }): Promise<void>;
    /**
     * Stop video recording (see [startRecording]) and resolves with a encoded video file 'video/webm' which dimensions correspond to the original video constraints.
     * @param discard if true it won't build the video and resolve with undefined.
     */
    stopRecording(discard?: boolean): Promise<Uint8ClampedArray | undefined>;
    /**
     * Main public method to capture the current frame on the video camera. [initialized] must be called first. Then this method can be called at will, optionally providing desired image output format.
     *
     * It will work even if [isPaused] since is independent of managed frame listening.
     *
     * Tip: right now, 'image/jpeg' seems to be faster then the rest, even rgba, on a x2.5 ratio (Reading jpg 30 fps on a canvas size  480, 320).. Nevertheless this could change/improve in the future.
     */
    readFrame(mime?: SupportedFormats, quality?: number): Promise<{
        width: number;
        height: number;
        data: Buffer;
    }>;
    protected notifyListeners(d: ImageData): Promise<void>;
    protected captureLoop(): Promise<void>;
}
