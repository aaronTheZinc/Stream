"use strict";
// These utilities are serialized (function.prototype.toString()) and evaluated in the browser's context so they must remain independent
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Self contained function to transform a [Blob] into [ArrayBuffer]. Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 */
function blobToArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        function onLoadEnd(e) {
            reader.removeEventListener('loadend', onLoadEnd, false);
            if (e.error) {
                reject(e.error);
            }
            else if (reader.result) {
                resolve(reader.result);
            }
            else {
                reject(new Error('Expected FileReader result'));
            }
        }
        reader.addEventListener('loadend', onLoadEnd, false);
        reader.readAsArrayBuffer(blob);
    });
}
exports.blobToArrayBuffer = blobToArrayBuffer;
/**
 * Reads given [HTMLCanvasElement] image encoded in given format and quality and return its content as [ArrayBuffer]. Depends on [blobToArrayBufferFn] which must be given or assumed to be global.  Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 * @param mime A DOMString indicating the image format. The default type is image/png.
 * @param quality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
 */
function canvasToArrayBuffer(canvas, mime = 'image/png', quality = 1, blobToArrayBufferFn = window.blobToArrayBuffer) {
    blobToArrayBufferFn = typeof blobToArrayBufferFn === 'function' ? blobToArrayBufferFn : window.blobToArrayBuffer;
    return new Promise((resolve, reject) => canvas.toBlob(async (blob) => {
        if (blob) {
            resolve(await blobToArrayBufferFn(blob));
        }
        else {
            reject(new Error('Expected toBlob() to be defined'));
        }
    }, mime, quality));
}
exports.canvasToArrayBuffer = canvasToArrayBuffer;
/**
 * Uses [MediaRecorder] to start recording current captured video.
 * Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 */
function startRecording(options = { video: document.querySelector('video'), mimeType: 'video/webm;codecs=vp8', width: 480, height: 320 }) {
    return new Promise(resolve => {
        options.video = options.video || document.querySelector('video');
        options.mimeType = options.mimeType || 'video/webm;codecs=vp8';
        options.width = options.width || 480;
        options.height = options.height || 320;
        const mediaSource = new MediaSource();
        let sourceBuffer;
        mediaSource.addEventListener('sourceopen', () => {
            sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
        }, false);
        window.recordedBlobs = [];
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            console.error(`${options.mimeType} is not Supported`);
            options = { ...options, mimeType: 'video/webm' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                console.error(`${options.mimeType} is not Supported`);
                options = { ...options, mimeType: '' };
            }
        }
        try {
            const mediaRecorder = new MediaRecorder(options.video.srcObject, options);
            mediaRecorder.onstop = (event) => {
                console.log('Recorder stopped: ', event);
            };
            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    window.recordedBlobs.push(event.data);
                }
            };
            mediaRecorder.start(10); // collect 10ms of data
            resolve();
        }
        catch (error) {
            console.error('Exception while creating MediaRecorder:', error, `Exception while creating MediaRecorder: ${JSON.stringify(error)}`);
            return;
        }
    });
}
exports.startRecording = startRecording;
//# sourceMappingURL=browser.js.map