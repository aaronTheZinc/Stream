/**
 * Self contained function to transform a [Blob] into [ArrayBuffer]. Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 */
export declare function blobToArrayBuffer(blob: Blob): Promise<ArrayBuffer>;
/**
 * Reads given [HTMLCanvasElement] image encoded in given format and quality and return its content as [ArrayBuffer]. Depends on [blobToArrayBufferFn] which must be given or assumed to be global.  Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 * @param mime A DOMString indicating the image format. The default type is image/png.
 * @param quality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
 */
export declare function canvasToArrayBuffer(canvas: HTMLCanvasElement, mime?: string, quality?: number, blobToArrayBufferFn?: typeof blobToArrayBuffer): Promise<ArrayBuffer>;
/**
 * Uses [MediaRecorder] to start recording current captured video.
 * Notice that this function is meant to be serialized and evaluated in a browser context that's why its dependencies must be controlled.
 */
export declare function startRecording(options?: StartRecordingOptions): Promise<unknown>;
export interface StartRecordingOptions {
    video: HTMLVideoElement;
    mimeType?: string;
    width?: number;
    height?: number;
}
import { TODO } from 'misc-utils-of-mine-generic';
export declare type MediaRecorderOptions = TODO;
export declare type RecordingState = TODO;
export declare type EventHandler = TODO;
export declare type OnDataAvailableListener = (e: {
    data: Blob;
}) => void;
export declare class MediaRecorder {
    constructor(stream: MediaStream, options: MediaRecorderOptions);
    readonly stream: MediaStream;
    readonly mimeType: string;
    readonly state: RecordingState;
    onstart: EventHandler;
    onstop: EventHandler;
    ondataavailable: OnDataAvailableListener;
    onpause: EventHandler;
    onresume: EventHandler;
    onerror: EventHandler;
    readonly videoBitsPerSecond: number;
    readonly audioBitsPerSecond: number;
    start(timeslice: number): void;
    stop(): void;
    pause(): void;
    resume(): void;
    requestData(): void;
    static isTypeSupported(type: string): boolean;
}
